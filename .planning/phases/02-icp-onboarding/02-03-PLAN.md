---
phase: 02-icp-onboarding
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/components/onboarding/steps/value-props-step.tsx
  - src/components/onboarding/steps/objections-step.tsx
  - src/lib/icp/actions.ts
  - src/app/api/icp/route.ts
autonomous: true

must_haves:
  truths:
    - "User can enter value propositions in wizard step 3"
    - "User can enter common objections in wizard step 4"
    - "ICP data can be saved to database"
    - "User can use AI to extract value props and objections"
  artifacts:
    - path: "src/components/onboarding/steps/value-props-step.tsx"
      provides: "Step 3 form for value propositions"
      exports: ["ValuePropsStep"]
    - path: "src/components/onboarding/steps/objections-step.tsx"
      provides: "Step 4 form for objections"
      exports: ["ObjectionsStep"]
    - path: "src/app/api/icp/route.ts"
      provides: "ICP CRUD API endpoints"
      exports: ["GET", "POST"]
  key_links:
    - from: "src/app/api/icp/route.ts"
      to: "src/lib/db/schema.ts"
      via: "database insert"
      pattern: "icpProfiles"
    - from: "src/lib/icp/actions.ts"
      to: "src/lib/ai/prompts/icp-parser.ts"
      via: "parsing function calls"
      pattern: "parseValueProps|parseObjections"
---

<objective>
Create wizard steps 3-4 (Value Props and Objections) and ICP persistence API.

Purpose: Complete the wizard form by adding the final two steps and enabling ICP data to be saved to the database. This plan can run in parallel with Plan 02 since they touch different step files.

Output: Value props and objections form steps, complete server actions for AI parsing, and API route for saving/loading ICP data.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-icp-onboarding/02-RESEARCH.md
@.planning/phases/02-icp-onboarding/02-01-SUMMARY.md
@src/lib/db/schema.ts
@src/lib/validations/icp.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Step 3 (Value Propositions) component</name>
  <files>
    src/components/onboarding/steps/value-props-step.tsx
  </files>
  <action>
Create `src/components/onboarding/steps/value-props-step.tsx`:
- "use client" directive
- Use useFormContext() and useFieldArray() for dynamic value props list
- Structure:
  - AI input at top: "Describe what makes your product valuable..."
  - List of value proposition cards
  - Each card has:
    - headline: Text input (short, punchy)
    - description: Textarea (longer explanation)
    - differentiators: Tag input (what makes this unique)
    - Remove button (if more than 1 prop)
  - "Add Value Proposition" button at bottom

Implementation details:
- Use useFieldArray({ name: 'valuePropositions' })
- append(), remove() for adding/removing props
- Minimum 1 value proposition required (validation in schema)
- Show validation errors per field in each card
- AI input uses parseValuePropsAction to extract multiple props
- When AI parses, replace entire array with AI output

Form structure per card:
```
<Card>
  <FormField name={`valuePropositions.${index}.headline`} />
  <FormField name={`valuePropositions.${index}.description`} />
  <FormField name={`valuePropositions.${index}.differentiators`} />
  <Button onClick={() => remove(index)}>Remove</Button>
</Card>
```
  </action>
  <verify>
Render step with FormProvider wrapper. Add/remove value props. Verify validation works on each nested field.
  </verify>
  <done>
Step 3 with dynamic value proposition list, all fields validated, AI input support.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Step 4 (Objections) component and complete server actions</name>
  <files>
    src/components/onboarding/steps/objections-step.tsx
    src/lib/icp/actions.ts
  </files>
  <action>
Create `src/components/onboarding/steps/objections-step.tsx`:
- "use client" directive
- Use useFormContext() and useFieldArray() for dynamic objections list
- Structure:
  - Helpful intro: "What objections do you commonly hear from prospects?"
  - AI input: "Describe common pushbacks you face..."
  - List of objection cards
  - Each card has:
    - objection: Textarea (the pushback they hear)
    - suggestedResponse: Textarea (optional - how they handle it)
    - Remove button
  - "Add Objection" button (can start with 0 objections - optional)
  - "Skip for now" option (objections are optional per schema)

Implementation similar to value-props-step but simpler fields.
AI input uses parseObjectionsAction to extract objections.

Complete `src/lib/icp/actions.ts` with all 4 parsing actions:
- 'use server' directive at top
- Each action:
  1. Get user from Supabase auth (createClient, getUser)
  2. If no user, throw Error('Unauthorized')
  3. Call corresponding parse function from lib/ai/prompts/icp-parser
  4. Return parsed result
  5. Wrap in try/catch, return null on error (let UI show fallback)

Export:
- parseCompanyInfoAction
- parseTargetCriteriaAction
- parseValuePropsAction
- parseObjectionsAction
  </action>
  <verify>
Render step 4, add/remove objections. Verify server actions are callable (may need OPENAI_API_KEY for full test).
  </verify>
  <done>
Step 4 with optional objections list, all 4 server actions for AI parsing complete.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create ICP API route for CRUD operations</name>
  <files>
    src/app/api/icp/route.ts
  </files>
  <action>
Create `src/app/api/icp/route.ts` for ICP CRUD:

GET handler:
- Auth check (createClient, getUser)
- Return 401 if not authenticated
- Query icpProfiles where userId = user.id
- Return single ICP (users have one ICP in v1)
- If no ICP exists, return null with 200

POST handler:
- Auth check
- Parse request body
- Validate with fullIcpSchema from validations/icp
- If validation fails, return 400 with errors
- Check if ICP exists for user:
  - If exists: UPDATE with new data, set updatedAt
  - If not exists: INSERT new row with userId
- Update profiles.has_completed_onboarding = true
- Return created/updated ICP with 200

Use Drizzle ORM for database operations:
```typescript
import { db } from '@/lib/db'
import { icpProfiles, profiles } from '@/lib/db/schema'
import { eq } from 'drizzle-orm'
```

Error handling:
- Database errors: 500 with generic message
- Validation errors: 400 with Zod error details
- Auth errors: 401

Response format:
```typescript
{ data: IcpProfile | null }
// or on error:
{ error: string, details?: ZodError }
```
  </action>
  <verify>
Test with curl:
- GET /api/icp (should return null or existing ICP)
- POST /api/icp with valid body (should create/update)
- POST with invalid body (should return 400)
  </verify>
  <done>
ICP API route handles GET and POST, validates input, saves to database, updates onboarding flag.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes without errors
2. Step 3 renders with add/remove value propositions functionality
3. Step 4 renders with optional objections list
4. All 4 server actions are exported and callable
5. GET /api/icp returns ICP data or null
6. POST /api/icp saves valid ICP data and updates has_completed_onboarding
</verification>

<success_criteria>
- Step 3: Dynamic value proposition cards with validation
- Step 4: Optional objections with skip option
- 4 server actions for AI parsing (auth-protected)
- API route for GET/POST ICP data
- POST updates has_completed_onboarding flag
- All TypeScript types align between schema, validation, and components
</success_criteria>

<output>
After completion, create `.planning/phases/02-icp-onboarding/02-03-SUMMARY.md`
</output>
