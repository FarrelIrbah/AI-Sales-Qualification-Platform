---
phase: 03-data-extraction
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - src/components/analyze/url-input.tsx
  - src/components/analyze/extraction-progress.tsx
  - src/components/analyze/manual-input-form.tsx
  - src/components/ui/alert.tsx
autonomous: true

must_haves:
  truths:
    - "User can paste a URL and submit for extraction"
    - "User sees extraction progress with stage updates"
    - "User can manually enter company data when needed"
    - "Manual form pre-fills with any partial data from extraction"
  artifacts:
    - path: "src/components/analyze/url-input.tsx"
      provides: "URL input component with validation"
      exports: ["UrlInput"]
    - path: "src/components/analyze/extraction-progress.tsx"
      provides: "Progress display during extraction"
      exports: ["ExtractionProgress"]
    - path: "src/components/analyze/manual-input-form.tsx"
      provides: "Manual company data entry form"
      exports: ["ManualInputForm"]
  key_links:
    - from: "src/components/analyze/extraction-progress.tsx"
      to: "/api/extract"
      via: "fetch POST request"
      pattern: "fetch.*api/extract"
    - from: "src/components/analyze/manual-input-form.tsx"
      to: "src/lib/validations/company.ts"
      via: "uses manualCompanyInputSchema"
      pattern: "manualCompanyInputSchema"
---

<objective>
Create the UI components for the data extraction flow: URL input, extraction progress display, and manual input form.

Purpose: These components provide the user interface for the extraction system. The design follows the CONTEXT.md decisions: step-by-step progress, silent fallback, and "never blank failure" principle.

Output: Three reusable components ready to be assembled in the /analyze page.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-data-extraction/03-CONTEXT.md

# Prior plan outputs
@.planning/phases/03-data-extraction/03-01-SUMMARY.md
@.planning/phases/03-data-extraction/03-02-SUMMARY.md

# Existing UI patterns
@src/components/ui/button.tsx
@src/components/ui/input.tsx
@src/components/ui/form.tsx
@src/components/ui/card.tsx
@src/components/ui/progress.tsx
@src/lib/validations/company.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: URL Input Component</name>
  <files>src/components/analyze/url-input.tsx</files>
  <action>
Create URL input component with validation:

```typescript
'use client';

import { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from '@/components/ui/form';
import { Loader2, Link as LinkIcon } from 'lucide-react';

const urlSchema = z.object({
  url: z
    .string()
    .min(1, 'Please enter a company URL')
    .refine(
      (val) => {
        try {
          const url = new URL(val.startsWith('http') ? val : `https://${val}`);
          return url.protocol === 'http:' || url.protocol === 'https:';
        } catch {
          return false;
        }
      },
      { message: 'Please enter a valid URL (e.g., company.com or https://company.com)' }
    ),
});

type UrlFormData = z.infer<typeof urlSchema>;

interface UrlInputProps {
  onSubmit: (url: string) => void;
  isLoading?: boolean;
  onManualClick?: () => void;
}

export function UrlInput({ onSubmit, isLoading = false, onManualClick }: UrlInputProps) {
  const form = useForm<UrlFormData>({
    resolver: zodResolver(urlSchema),
    defaultValues: { url: '' },
  });

  function handleSubmit(data: UrlFormData) {
    // Normalize URL - add https:// if no protocol
    const normalizedUrl = data.url.startsWith('http')
      ? data.url
      : `https://${data.url}`;
    onSubmit(normalizedUrl);
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(handleSubmit)} className="space-y-4">
        <FormField
          control={form.control}
          name="url"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Company Website</FormLabel>
              <FormControl>
                <div className="relative">
                  <LinkIcon className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                  <Input
                    {...field}
                    placeholder="Enter company URL (e.g., stripe.com)"
                    className="pl-10"
                    disabled={isLoading}
                  />
                </div>
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <div className="flex gap-3">
          <Button type="submit" disabled={isLoading} className="flex-1">
            {isLoading ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Extracting...
              </>
            ) : (
              'Extract Company Data'
            )}
          </Button>

          {onManualClick && (
            <Button
              type="button"
              variant="outline"
              onClick={onManualClick}
              disabled={isLoading}
            >
              Enter Manually
            </Button>
          )}
        </div>
      </form>
    </Form>
  );
}
```

Key features:
- URL validation with helpful error messages
- Auto-adds https:// if no protocol provided
- Loading state with spinner
- Optional "Enter Manually" button
- Uses existing form components and patterns
  </action>
  <verify>
Run `npm run build` to verify component compiles.
Component should be importable without errors.
  </verify>
  <done>
URL input component validates URLs, handles loading state, provides manual entry option.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extraction Progress Component</name>
  <files>src/components/analyze/extraction-progress.tsx</files>
  <action>
Create progress component showing extraction stages:

```typescript
'use client';

import { useState, useEffect, useCallback } from 'react';
import { Progress } from '@/components/ui/progress';
import { Card, CardContent } from '@/components/ui/card';
import { Check, Loader2, AlertCircle } from 'lucide-react';
import type { ExtractionResult } from '@/lib/extraction/fallback-chain';
import type { PartialCompanyData } from '@/lib/validations/company';

interface ExtractionStep {
  name: string;
  status: 'pending' | 'running' | 'success' | 'failed' | 'skipped';
}

interface ExtractionProgressProps {
  url: string;
  onComplete: (result: ExtractionResult) => void;
  onError: (partialData: PartialCompanyData, missingFields: string[]) => void;
}

export function ExtractionProgress({
  url,
  onComplete,
  onError,
}: ExtractionProgressProps) {
  const [steps, setSteps] = useState<ExtractionStep[]>([
    { name: 'Fetching website', status: 'pending' },
    { name: 'Extracting company info', status: 'pending' },
    { name: 'Enriching data', status: 'pending' },
    { name: 'Finalizing', status: 'pending' },
  ]);
  const [currentStep, setCurrentStep] = useState(0);
  const [error, setError] = useState<string | null>(null);

  const updateStep = useCallback((index: number, status: ExtractionStep['status']) => {
    setSteps((prev) =>
      prev.map((step, i) => (i === index ? { ...step, status } : step))
    );
  }, []);

  useEffect(() => {
    let mounted = true;
    const controller = new AbortController();

    async function runExtraction() {
      try {
        // Step 1: Fetching website (simulated stage)
        updateStep(0, 'running');
        setCurrentStep(0);

        // Small delay to show step animation
        await new Promise((r) => setTimeout(r, 500));
        if (!mounted) return;
        updateStep(0, 'success');

        // Step 2: Extracting (actual API call happens here)
        updateStep(1, 'running');
        setCurrentStep(1);

        const response = await fetch('/api/extract', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ url }),
          signal: controller.signal,
        });

        if (!mounted) return;

        const result: ExtractionResult = await response.json();

        // Step 2 complete
        updateStep(1, result.sources.includes('scrape') ? 'success' : 'skipped');

        // Step 3: Enriching (show based on result)
        updateStep(2, 'running');
        setCurrentStep(2);
        await new Promise((r) => setTimeout(r, 300));
        if (!mounted) return;

        updateStep(
          2,
          result.sources.includes('enrichment')
            ? 'success'
            : result.sources.includes('scrape')
            ? 'skipped'
            : 'failed'
        );

        // Step 4: Finalizing
        updateStep(3, 'running');
        setCurrentStep(3);
        await new Promise((r) => setTimeout(r, 300));
        if (!mounted) return;
        updateStep(3, 'success');

        // Complete
        if (result.needsManualInput) {
          onError(result.data, result.missingFields);
        } else {
          onComplete(result);
        }
      } catch (err) {
        if (!mounted) return;

        if (err instanceof Error && err.name === 'AbortError') {
          return; // User cancelled
        }

        console.error('Extraction error:', err);
        setError('Failed to extract company data');

        // Always provide fallback
        onError({}, ['name', 'industry', 'description']);
      }
    }

    runExtraction();

    return () => {
      mounted = false;
      controller.abort();
    };
  }, [url, onComplete, onError, updateStep]);

  const progress = ((currentStep + 1) / steps.length) * 100;

  const StepIcon = ({ status }: { status: ExtractionStep['status'] }) => {
    switch (status) {
      case 'running':
        return <Loader2 className="h-4 w-4 animate-spin text-primary" />;
      case 'success':
        return <Check className="h-4 w-4 text-green-500" />;
      case 'failed':
        return <AlertCircle className="h-4 w-4 text-red-500" />;
      case 'skipped':
        return <span className="h-4 w-4 text-muted-foreground">-</span>;
      default:
        return <span className="h-4 w-4 rounded-full border border-muted-foreground" />;
    }
  };

  return (
    <Card>
      <CardContent className="pt-6">
        <div className="space-y-4">
          <Progress value={progress} className="h-2" />

          <div className="space-y-2">
            {steps.map((step, i) => (
              <div
                key={i}
                className={`flex items-center gap-3 transition-opacity ${
                  step.status === 'pending' ? 'opacity-50' : ''
                }`}
              >
                <StepIcon status={step.status} />
                <span
                  className={
                    step.status === 'running'
                      ? 'text-primary font-medium'
                      : step.status === 'success'
                      ? 'text-foreground'
                      : 'text-muted-foreground'
                  }
                >
                  {step.name}
                </span>
              </div>
            ))}
          </div>

          {error && (
            <p className="text-sm text-red-500 mt-2">{error}</p>
          )}
        </div>
      </CardContent>
    </Card>
  );
}
```

Key features:
- Step-by-step progress visualization
- Icons for each status (running, success, failed, skipped)
- Silent fallback - shows "skipped" instead of "failed" for graceful degradation
- Abort controller for cleanup
- Always calls onError with partial data on failure (never blank)
  </action>
  <verify>
Run `npm run build` to verify component compiles.
Check that ExtractionResult type is correctly imported.
  </verify>
  <done>
Progress component shows extraction stages, handles all outcomes, never leaves user without next action.
  </done>
</task>

<task type="auto">
  <name>Task 3: Manual Input Form Component</name>
  <files>src/components/analyze/manual-input-form.tsx, src/components/ui/alert.tsx</files>
  <action>
First, create the Alert component (needed for highlighting gaps):

**src/components/ui/alert.tsx:**
```typescript
import * as React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '@/lib/utils';

const alertVariants = cva(
  'relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground',
  {
    variants: {
      variant: {
        default: 'bg-background text-foreground',
        destructive:
          'border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive',
        warning:
          'border-yellow-500/50 text-yellow-700 dark:text-yellow-500 [&>svg]:text-yellow-500',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  }
);

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
));
Alert.displayName = 'Alert';

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn('mb-1 font-medium leading-none tracking-tight', className)}
    {...props}
  />
));
AlertTitle.displayName = 'AlertTitle';

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn('text-sm [&_p]:leading-relaxed', className)}
    {...props}
  />
));
AlertDescription.displayName = 'AlertDescription';

export { Alert, AlertTitle, AlertDescription };
```

**src/components/analyze/manual-input-form.tsx:**
```typescript
'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
  FormDescription,
} from '@/components/ui/form';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { AlertCircle } from 'lucide-react';
import {
  manualCompanyInputSchema,
  type ManualCompanyInput,
  type PartialCompanyData,
} from '@/lib/validations/company';

// Common industries for dropdown
const INDUSTRIES = [
  'Technology',
  'Healthcare',
  'Finance',
  'E-commerce',
  'Manufacturing',
  'Education',
  'Real Estate',
  'Professional Services',
  'Media & Entertainment',
  'Other',
] as const;

// Employee count ranges
const EMPLOYEE_COUNTS = [
  { value: '1-10', label: '1-10 employees' },
  { value: '11-50', label: '11-50 employees' },
  { value: '51-200', label: '51-200 employees' },
  { value: '201-500', label: '201-500 employees' },
  { value: '501-1000', label: '501-1,000 employees' },
  { value: '1001+', label: '1,000+ employees' },
] as const;

interface ManualInputFormProps {
  initialData?: PartialCompanyData;
  missingFields?: string[];
  onSubmit: (data: ManualCompanyInput) => void;
  onBack?: () => void;
  submitLabel?: string;
}

export function ManualInputForm({
  initialData = {},
  missingFields = [],
  onSubmit,
  onBack,
  submitLabel = 'Continue to Analysis',
}: ManualInputFormProps) {
  const form = useForm<ManualCompanyInput>({
    resolver: zodResolver(manualCompanyInputSchema),
    defaultValues: {
      name: initialData.name ?? '',
      industry: initialData.industry ?? '',
      description: initialData.description ?? '',
      employeeCount: initialData.employeeCount ?? '',
      location: initialData.location ?? '',
    },
  });

  const isMissing = (field: string) => missingFields.includes(field);

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
        {missingFields.length > 0 && (
          <Alert variant="warning">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>
              We couldn&apos;t automatically extract some information.
              Please fill in the highlighted fields below.
            </AlertDescription>
          </Alert>
        )}

        <FormField
          control={form.control}
          name="name"
          render={({ field }) => (
            <FormItem>
              <FormLabel className={isMissing('name') ? 'text-yellow-600' : ''}>
                Company Name {isMissing('name') && '*'}
              </FormLabel>
              <FormControl>
                <Input
                  {...field}
                  placeholder="e.g., Acme Corporation"
                  className={isMissing('name') ? 'border-yellow-500' : ''}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="industry"
          render={({ field }) => (
            <FormItem>
              <FormLabel className={isMissing('industry') ? 'text-yellow-600' : ''}>
                Industry {isMissing('industry') && '*'}
              </FormLabel>
              <Select
                onValueChange={field.onChange}
                defaultValue={field.value}
              >
                <FormControl>
                  <SelectTrigger
                    className={isMissing('industry') ? 'border-yellow-500' : ''}
                  >
                    <SelectValue placeholder="Select industry" />
                  </SelectTrigger>
                </FormControl>
                <SelectContent>
                  {INDUSTRIES.map((industry) => (
                    <SelectItem key={industry} value={industry}>
                      {industry}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="description"
          render={({ field }) => (
            <FormItem>
              <FormLabel className={isMissing('description') ? 'text-yellow-600' : ''}>
                Description {isMissing('description') && '(optional)'}
              </FormLabel>
              <FormControl>
                <Textarea
                  {...field}
                  placeholder="Brief description of what the company does..."
                  rows={3}
                  className={isMissing('description') ? 'border-yellow-500' : ''}
                />
              </FormControl>
              <FormDescription>
                What does this company do? This helps with analysis.
              </FormDescription>
              <FormMessage />
            </FormItem>
          )}
        />

        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <FormField
            control={form.control}
            name="employeeCount"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Company Size</FormLabel>
                <Select
                  onValueChange={field.onChange}
                  defaultValue={field.value}
                >
                  <FormControl>
                    <SelectTrigger>
                      <SelectValue placeholder="Select size" />
                    </SelectTrigger>
                  </FormControl>
                  <SelectContent>
                    {EMPLOYEE_COUNTS.map((size) => (
                      <SelectItem key={size.value} value={size.value}>
                        {size.label}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="location"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Location</FormLabel>
                <FormControl>
                  <Input
                    {...field}
                    placeholder="e.g., San Francisco, CA"
                  />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />
        </div>

        <div className="flex gap-3 pt-4">
          {onBack && (
            <Button type="button" variant="outline" onClick={onBack}>
              Back
            </Button>
          )}
          <Button type="submit" className="flex-1">
            {submitLabel}
          </Button>
        </div>
      </form>
    </Form>
  );
}
```

Key features:
- Pre-fills with any partial data from extraction
- Highlights missing fields with yellow border and asterisk
- Warning alert explaining what happened
- Industry dropdown with common options
- Employee count dropdown with ranges
- Responsive two-column layout for size/location
- Optional back button for navigation
  </action>
  <verify>
Run `npm run build` to verify components compile.
Verify Alert component exports correctly.
Verify ManualInputForm handles empty initialData.
  </verify>
  <done>
Manual input form pre-fills partial data, highlights gaps, validates required fields, submits ManualCompanyInput.
  </done>
</task>

</tasks>

<verification>
All three UI components compile and follow project patterns:
- `npm run build` passes
- Components use existing UI primitives (Button, Input, Form, etc.)
- Components handle all states (loading, success, error, partial)
- Manual form properly highlights missing fields
</verification>

<success_criteria>
1. UrlInput validates URLs and handles https:// normalization
2. ExtractionProgress shows step-by-step progress and handles all outcomes
3. ManualInputForm pre-fills partial data and highlights missing fields
4. Alert component created for warning display
5. All components use existing UI patterns and Tailwind classes
6. `npm run build` passes with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-data-extraction/03-03-SUMMARY.md`
</output>
