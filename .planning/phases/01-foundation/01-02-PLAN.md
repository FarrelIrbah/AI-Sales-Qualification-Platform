---
phase: 01-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/db/index.ts
  - src/lib/db/schema.ts
  - drizzle.config.ts
  - supabase/migrations/0001_create_profiles.sql
autonomous: true
user_setup:
  - service: supabase
    why: "Database and authentication backend"
    env_vars:
      - name: NEXT_PUBLIC_SUPABASE_URL
        source: "Supabase Dashboard > Settings > API > Project URL"
      - name: NEXT_PUBLIC_SUPABASE_ANON_KEY
        source: "Supabase Dashboard > Settings > API > anon public key"
      - name: DATABASE_URL
        source: "Supabase Dashboard > Settings > Database > Connection string (Transaction pooler)"
    dashboard_config:
      - task: "Create new Supabase project"
        location: "supabase.com > New Project"
      - task: "Enable Google OAuth provider"
        location: "Supabase Dashboard > Authentication > Providers > Google"

must_haves:
  truths:
    - "Profiles table exists in database"
    - "RLS policies restrict profile access to owner only"
    - "New auth.users trigger auto-creates profile row"
    - "Drizzle can query the profiles table"
  artifacts:
    - path: "src/lib/db/schema.ts"
      provides: "Database schema definitions"
      exports: ["profiles"]
    - path: "src/lib/db/index.ts"
      provides: "Drizzle database client"
      exports: ["db"]
    - path: "drizzle.config.ts"
      provides: "Drizzle migration config"
      contains: "drizzle.config"
    - path: "supabase/migrations/0001_create_profiles.sql"
      provides: "Profiles table migration"
      contains: "CREATE TABLE"
  key_links:
    - from: "src/lib/db/index.ts"
      to: "src/lib/db/schema.ts"
      via: "schema import"
      pattern: "import.*schema"
    - from: "supabase/migrations/0001_create_profiles.sql"
      to: "auth.users"
      via: "foreign key reference"
      pattern: "REFERENCES auth.users"
---

<objective>
Create the database schema for user profiles with RLS policies and Drizzle ORM integration.

Purpose: Establish the data layer that stores extended user information beyond Supabase auth.
Output: Profiles table with RLS policies, Drizzle schema, and auto-creation trigger.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Drizzle schema and database client</name>
  <files>
    - src/lib/db/schema.ts
    - src/lib/db/index.ts
    - drizzle.config.ts
  </files>
  <action>
Create the Drizzle ORM configuration and schema files:

**src/lib/db/schema.ts**:
```typescript
import { pgTable, uuid, text, timestamp, boolean } from 'drizzle-orm/pg-core'
import { sql } from 'drizzle-orm'

export const profiles = pgTable('profiles', {
  id: uuid('id').primaryKey(),
  email: text('email').notNull(),
  fullName: text('full_name'),
  avatarUrl: text('avatar_url'),
  hasCompletedOnboarding: boolean('has_completed_onboarding').default(false).notNull(),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
})

// Type exports for use throughout the app
export type Profile = typeof profiles.$inferSelect
export type NewProfile = typeof profiles.$inferInsert
```

Note: We define the schema in Drizzle for type generation but use raw SQL migrations for the actual table creation (including RLS policies and triggers which Drizzle doesn't handle well).

**src/lib/db/index.ts**:
```typescript
import { drizzle } from 'drizzle-orm/postgres-js'
import postgres from 'postgres'
import * as schema from './schema'

// Use connection pooler URL for serverless environments
// The `prepare: false` is required for connection poolers
const connectionString = process.env.DATABASE_URL!

const client = postgres(connectionString, { prepare: false })
export const db = drizzle(client, { schema })
```

**drizzle.config.ts**:
```typescript
import { defineConfig } from 'drizzle-kit'

export default defineConfig({
  schema: './src/lib/db/schema.ts',
  out: './supabase/migrations',
  dialect: 'postgresql',
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
})
```

Add npm scripts to package.json for Drizzle:
```json
{
  "scripts": {
    "db:generate": "drizzle-kit generate",
    "db:push": "drizzle-kit push",
    "db:studio": "drizzle-kit studio"
  }
}
```
  </action>
  <verify>
Run `npm run db:generate` and confirm it completes without errors (may show no changes if schema matches).
  </verify>
  <done>
Drizzle schema and client configured. Profile type is exported for use in components.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create profiles table migration with RLS and trigger</name>
  <files>
    - supabase/migrations/0001_create_profiles.sql
  </files>
  <action>
Create the SQL migration file that sets up the profiles table, RLS policies, and the trigger for auto-creating profiles on user signup.

**supabase/migrations/0001_create_profiles.sql**:
```sql
-- Create profiles table
CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  email TEXT NOT NULL,
  full_name TEXT,
  avatar_url TEXT,
  has_completed_onboarding BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Enable RLS
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- RLS Policies: Users can only access their own profile
CREATE POLICY "Users can view own profile"
  ON public.profiles
  FOR SELECT
  TO authenticated
  USING (id = auth.uid());

CREATE POLICY "Users can update own profile"
  ON public.profiles
  FOR UPDATE
  TO authenticated
  USING (id = auth.uid())
  WITH CHECK (id = auth.uid());

-- Note: INSERT policy is not needed for regular users since profiles
-- are created by the trigger with SECURITY DEFINER

-- Function to handle new user creation
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, avatar_url)
  VALUES (
    NEW.id,
    NEW.email,
    NEW.raw_user_meta_data ->> 'full_name',
    NEW.raw_user_meta_data ->> 'avatar_url'
  );
  RETURN NEW;
END;
$$;

-- Trigger to auto-create profile on user signup
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_new_user();

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION public.update_updated_at()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- Trigger to auto-update updated_at
DROP TRIGGER IF EXISTS update_profiles_updated_at ON public.profiles;
CREATE TRIGGER update_profiles_updated_at
  BEFORE UPDATE ON public.profiles
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at();

-- Create index for email lookups
CREATE INDEX IF NOT EXISTS profiles_email_idx ON public.profiles(email);
```

This migration must be run in the Supabase SQL Editor or via Supabase CLI. The file serves as documentation and can be executed manually.

Important: This SQL must be run in Supabase Dashboard > SQL Editor before testing auth flows. The trigger is critical - without it, signups will succeed in auth.users but profiles won't be created.
  </action>
  <verify>
Open Supabase Dashboard > SQL Editor, paste the migration SQL, and execute it. Then verify:
1. Navigate to Table Editor > profiles - table should exist
2. Navigate to Authentication > Policies - RLS policies should be listed
3. Navigate to Database > Triggers - on_auth_user_created should exist
  </verify>
  <done>
Profiles table created with RLS policies and auto-creation trigger. Database is ready for authentication flows.
  </done>
</task>

</tasks>

<verification>
After running the migration in Supabase:

1. Profiles table visible in Supabase Table Editor
2. RLS enabled (lock icon on table)
3. Two policies visible: "Users can view own profile" and "Users can update own profile"
4. Trigger visible in Database > Triggers
5. Run a test query in SQL Editor: `SELECT * FROM public.profiles;` (should return empty, no errors)
</verification>

<success_criteria>
- Drizzle schema exports Profile type
- Database client connects via connection pooler
- Profiles table exists in Supabase
- RLS policies restrict access to owner only
- Trigger auto-creates profile on auth.users insert
- updated_at auto-updates on profile changes
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
