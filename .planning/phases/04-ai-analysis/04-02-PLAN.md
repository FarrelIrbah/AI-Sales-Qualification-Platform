---
phase: 04-ai-analysis
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/lib/ai/prompts/lead-analyzer.ts
  - src/lib/analysis/actions.ts
  - src/app/api/analyze/route.ts
autonomous: true

must_haves:
  truths:
    - "AI generates structured analysis from company data + ICP"
    - "Analysis results are saved to database"
    - "API endpoint returns analysis result or error"
  artifacts:
    - path: "src/lib/ai/prompts/lead-analyzer.ts"
      provides: "AI prompt and analysis function"
      exports: ["analyzeLeadWithAI"]
    - path: "src/lib/analysis/actions.ts"
      provides: "Server actions for analysis"
      exports: ["createAnalysis", "getAnalysis"]
    - path: "src/app/api/analyze/route.ts"
      provides: "POST endpoint for running analysis"
      exports: ["POST"]
  key_links:
    - from: "src/lib/ai/prompts/lead-analyzer.ts"
      to: "@google/generative-ai"
      via: "geminiFlash.generateContent"
      pattern: "geminiFlash\\.generateContent"
    - from: "src/lib/analysis/actions.ts"
      to: "src/lib/db/schema.ts"
      via: "drizzle insert"
      pattern: "db\\.insert\\(analyses\\)"
    - from: "src/app/api/analyze/route.ts"
      to: "src/lib/ai/prompts/lead-analyzer.ts"
      via: "analyzeLeadWithAI call"
      pattern: "analyzeLeadWithAI"
---

<objective>
Implement AI-powered lead analysis that generates scores, pitches, and objection predictions.

Purpose: This is the core AI intelligence of the product - without it, users just see extracted data without insights.

Output: AI prompt module, server actions for analysis CRUD, and API endpoint for triggering analysis.
</objective>

<execution_context>
@C:\Users\farre\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\farre\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-ai-analysis/04-CONTEXT.md
@.planning/phases/04-ai-analysis/04-RESEARCH.md
@.planning/phases/04-ai-analysis/04-01-SUMMARY.md

@src/lib/ai/index.ts
@src/lib/ai/prompts/icp-parser.ts
@src/lib/analysis/schemas.ts
@src/lib/db/schema.ts
@src/lib/validations/company.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Lead Analyzer AI Prompt</name>
  <files>src/lib/ai/prompts/lead-analyzer.ts</files>
  <action>
Create AI prompt module following the exact pattern from `icp-parser.ts`.

System prompt should instruct Gemini to:
1. Act as an expert B2B sales analyst
2. Analyze company data against user's ICP
3. Generate comprehensive analysis with ALL fields in ONE response

Prompt structure:
```typescript
const ANALYSIS_SYSTEM_PROMPT = `You are an expert B2B sales analyst who evaluates lead quality and generates sales intelligence.

Given:
- Target company data (extracted from their website)
- User's ICP profile (their ideal customer criteria, value props, and common objections)

Generate a comprehensive lead analysis including:

1. LEAD SCORE (1-100): Overall qualification score
   - 70-100 = Strong Fit (green)
   - 40-69 = Moderate Fit (yellow)
   - 0-39 = Weak Fit (red)

2. ICP MATCH PERCENTAGE (0-100): How closely company matches ideal criteria

3. COMPONENT SCORES: Score each dimension 0-100 with reasoning:
   - Industry Fit: How well their industry matches target industries
   - Size Fit: How well their company size matches ideal sizes
   - Tech Fit: Overlap between their tech stack and required technologies
   - Need Signals: Indicators they need what user sells
   - Location Fit: Geographic alignment with target locations
   - Growth Signals: Signs of growth/budget (hiring, funding, expansion)

4. COMPANY INSIGHTS:
   - summary: 1-2 sentence interpretive commentary
   - strengths: 2-4 positive signals for this lead
   - concerns: 1-3 potential issues or gaps

5. PITCH ANGLES (2-3 distinct approaches):
   Each with headline hook + explanation + why it works for THIS company

6. PREDICTED OBJECTIONS (1-4) with recommended responses:
   Based on company profile vs user's known objections

CRITICAL RULES:
- Only reference information provided in company data - do NOT invent details
- If data is sparse, acknowledge uncertainty and provide best estimates
- Scores must be integers 0-100
- Each component score MUST include reasoning
- Be professional and direct - like a sales coach

Respond ONLY with valid JSON matching this exact structure:
{
  "leadScore": number,
  "icpMatchPercentage": number,
  "componentScores": [
    { "name": "Industry Fit", "score": number, "weight": number, "reasoning": "string" },
    ...
  ],
  "insights": {
    "summary": "string",
    "strengths": ["string"],
    "concerns": ["string"]
  },
  "pitchAngles": [
    { "headline": "string", "explanation": "string", "whyItWorks": "string" }
  ],
  "objections": [
    { "objection": "string", "likelihood": "high"|"medium"|"low", "recommendedResponse": "string" }
  ]
}`;
```

Implement `analyzeLeadWithAI` function:
```typescript
export async function analyzeLeadWithAI(
  companyData: PartialCompanyData,
  icpProfile: IcpProfile
): Promise<AnalysisResult | null>
```

Use the extractJson helper pattern from icp-parser.ts.
Validate output with analysisResultSchema.safeParse().
Return null on failure (let caller handle fallback).
Set maxOutputTokens: 2048 to prevent cost explosion.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify types compile.
Test with console.log in dev mode to verify JSON structure.
  </verify>
  <done>
AI prompt generates valid JSON that passes Zod validation. Function returns AnalysisResult or null.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Analysis Server Actions</name>
  <files>src/lib/analysis/actions.ts</files>
  <action>
Create server actions following pattern from `src/lib/icp/actions.ts`.

Add 'use server' directive at top.

Implement:

1. `createAnalysis` - Save analysis to database:
```typescript
export async function createAnalysis(
  companyId: string,
  icpProfileId: string,
  result: AnalysisResult
): Promise<{ success: true; analysisId: string } | { success: false; error: string }>
```
- Get authenticated user via createClient()
- Insert into analyses table with all fields
- Return analysis ID on success

2. `getAnalysis` - Retrieve analysis by ID:
```typescript
export async function getAnalysis(
  analysisId: string
): Promise<Analysis | null>
```
- Verify user owns the analysis (join on userId)
- Return full analysis record

3. `getAnalysesForCompany` - Get all analyses for a company:
```typescript
export async function getAnalysesForCompany(
  companyId: string
): Promise<Analysis[]>
```
- Filter by companyId and userId
- Order by createdAt desc

Import db from '@/lib/db', analyses/companies/icpProfiles from schema.
Use eq() from drizzle-orm for where clauses.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify actions compile.
Test createAnalysis by calling from API route.
  </verify>
  <done>
Server actions exist, properly authenticated, and can save/retrieve analyses.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Analysis API Endpoint</name>
  <files>src/app/api/analyze/route.ts</files>
  <action>
Create POST endpoint that orchestrates the full analysis flow.

Request body:
```typescript
{
  companyData: PartialCompanyData;  // From extraction
  companyId?: string;               // If company already saved
  url: string;                      // Original URL for saving
}
```

Endpoint flow:
1. Authenticate user
2. Get user's ICP profile (required for analysis)
3. If no companyId, save company to database first
4. Call analyzeLeadWithAI(companyData, icpProfile)
5. If AI returns null, return 500 with error
6. Save analysis via createAnalysis()
7. Return analysis result with analysisId

Response on success (200):
```typescript
{
  analysisId: string;
  analysis: AnalysisResult;
}
```

Response on error:
- 401 if not authenticated
- 400 if no ICP profile exists (user needs to complete onboarding)
- 500 if AI analysis fails

Handle edge cases:
- If ICP profile not found, return helpful error message
- If company save fails, return error before attempting analysis
- Log token usage from Gemini response for monitoring

Follow existing API pattern from `src/app/api/extract/route.ts`.
  </action>
  <verify>
Test with curl or browser:
```bash
curl -X POST http://localhost:3000/api/analyze \
  -H "Content-Type: application/json" \
  -d '{"companyData": {"name": "Test Corp", "industry": "SaaS"}, "url": "https://test.com"}'
```
Should return 401 if not logged in, 400 if no ICP, or analysis result if successful.
  </verify>
  <done>
API endpoint accepts company data, runs AI analysis, saves results, and returns analysis with ID.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. AI prompt generates valid JSON when tested
3. Server actions properly save to database
4. API endpoint handles auth, validation, and errors
5. Full flow: company data in -> analysis out -> saved to DB
</verification>

<success_criteria>
- AI generates lead scores 0-100 with component breakdown
- Pitch angles are personalized to company + ICP
- Objections reference user's known objections from ICP
- Results persist in database with correct foreign keys
- API returns structured response with analysisId
</success_criteria>

<output>
After completion, create `.planning/phases/04-ai-analysis/04-02-SUMMARY.md`
</output>
