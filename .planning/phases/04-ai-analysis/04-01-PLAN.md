---
phase: 04-ai-analysis
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/analysis/schemas.ts
  - src/lib/db/schema.ts
  - drizzle/0003_analyses.sql
autonomous: true

must_haves:
  truths:
    - "Analysis result types exist and are importable"
    - "Analyses table exists in database with JSONB columns"
    - "Zod schemas validate AI output structure"
  artifacts:
    - path: "src/lib/analysis/schemas.ts"
      provides: "Analysis Zod schemas and TypeScript types"
      exports: ["analysisResultSchema", "componentScoreSchema", "pitchAngleSchema", "predictedObjectionSchema", "AnalysisResult", "ComponentScore", "PitchAngle", "PredictedObjection"]
    - path: "src/lib/db/schema.ts"
      provides: "Analyses table with JSONB columns"
      contains: "analyses = pgTable"
    - path: "drizzle/0003_analyses.sql"
      provides: "Database migration for analyses table"
      contains: "CREATE TABLE"
  key_links:
    - from: "src/lib/analysis/schemas.ts"
      to: "src/lib/db/schema.ts"
      via: "Type consistency between Zod and Drizzle"
      pattern: "ComponentScore|PitchAngle|PredictedObjection"
---

<objective>
Create analysis data schemas and database table for storing lead analysis results.

Purpose: Establishes the data foundation for AI analysis - without schemas and database, there's nothing to generate or store.

Output: Zod validation schemas, TypeScript types, Drizzle table definition, and database migration.
</objective>

<execution_context>
@C:\Users\farre\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\farre\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-ai-analysis/04-CONTEXT.md
@.planning/phases/04-ai-analysis/04-RESEARCH.md

@src/lib/db/schema.ts
@src/lib/validations/icp.ts
@src/lib/validations/company.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Analysis Zod Schemas</name>
  <files>src/lib/analysis/schemas.ts</files>
  <action>
Create analysis validation schemas following existing pattern from `src/lib/validations/icp.ts`.

Define these schemas:
1. `componentScoreSchema` - Individual component score:
   - `name`: string (e.g., "Industry Fit", "Size Fit", "Tech Fit", "Need Signals", "Location Fit", "Growth Signals")
   - `score`: number 0-100 with `.min(0).max(100)`
   - `weight`: number 0-1 (for weighted average calculation)
   - `reasoning`: string (AI explanation for this score)

2. `pitchAngleSchema` - Pitch recommendation:
   - `headline`: string (bold hook, 5-10 words)
   - `explanation`: string (2-3 sentences on the angle)
   - `whyItWorks`: string (why this resonates with target company)

3. `predictedObjectionSchema` - Objection with response:
   - `objection`: string (the likely pushback)
   - `likelihood`: enum ['high', 'medium', 'low']
   - `recommendedResponse`: string (how to handle it)

4. `companyInsightsSchema` - AI commentary on company:
   - `summary`: string (interpretive commentary like "Fast-growing fintech with modern stack")
   - `strengths`: array of strings (positive signals)
   - `concerns`: array of strings (potential issues)

5. `analysisResultSchema` - Complete analysis output:
   - `leadScore`: number 0-100
   - `icpMatchPercentage`: number 0-100
   - `componentScores`: array of componentScoreSchema (min 4, max 6)
   - `insights`: companyInsightsSchema
   - `pitchAngles`: array of pitchAngleSchema (min 2, max 3)
   - `objections`: array of predictedObjectionSchema (min 1, max 4)

Export all schemas and inferred types:
- `export type AnalysisResult = z.infer<typeof analysisResultSchema>`
- Same pattern for ComponentScore, PitchAngle, PredictedObjection, CompanyInsights

Include helper function `getScoreLabel(score: number): string` that returns:
- "Strong Fit" for score >= 70
- "Moderate Fit" for score >= 40
- "Weak Fit" for score < 40
  </action>
  <verify>
Run `npx tsc --noEmit` to verify schemas compile without errors.
Check that all types are exported correctly with `grep -n "export type" src/lib/analysis/schemas.ts`.
  </verify>
  <done>
Schema file exists with all 5 schemas defined, TypeScript types exported, and helper function implemented.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Analyses Table to Database Schema</name>
  <files>src/lib/db/schema.ts</files>
  <action>
Add `analyses` table to existing schema following the pattern from `companies` table.

Table structure:
```typescript
// JSONB column types for analyses (import from schemas.ts)
import type { ComponentScore, PitchAngle, PredictedObjection, CompanyInsights } from '@/lib/analysis/schemas'

export const analyses = pgTable('analyses', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id')
    .notNull()
    .references(() => profiles.id, { onDelete: 'cascade' }),
  companyId: uuid('company_id')
    .notNull()
    .references(() => companies.id, { onDelete: 'cascade' }),
  icpProfileId: uuid('icp_profile_id')
    .notNull()
    .references(() => icpProfiles.id, { onDelete: 'cascade' }),

  // Core scores (flat for querying/filtering in Phase 5)
  leadScore: integer('lead_score').notNull(),
  icpMatchPercentage: integer('icp_match_percentage').notNull(),

  // Complex nested data as JSONB
  componentScores: jsonb('component_scores').$type<ComponentScore[]>().notNull(),
  insights: jsonb('insights').$type<CompanyInsights>().notNull(),
  pitchAngles: jsonb('pitch_angles').$type<PitchAngle[]>().notNull(),
  objections: jsonb('objections').$type<PredictedObjection[]>().notNull(),

  // Timestamps
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
})
```

Add type exports:
```typescript
export type Analysis = typeof analyses.$inferSelect
export type NewAnalysis = typeof analyses.$inferInsert
```

Import `integer` from drizzle-orm/pg-core (add to existing import statement).
  </action>
  <verify>
Run `npx tsc --noEmit` to verify schema compiles.
Run `npx drizzle-kit generate` to generate migration file.
  </verify>
  <done>
Analyses table defined in schema.ts with all columns, type exports added, and Drizzle generates valid migration.
  </done>
</task>

<task type="auto">
  <name>Task 3: Run Database Migration</name>
  <files>drizzle/0003_analyses.sql</files>
  <action>
After generating migration with `npx drizzle-kit generate`:

1. Verify the generated migration creates the analyses table correctly
2. Run `npx drizzle-kit push` to apply migration to Supabase database
3. Verify table exists in database

The migration should create:
- analyses table with all columns
- Foreign key constraints to profiles, companies, icp_profiles
- ON DELETE CASCADE behavior
- Default values for timestamps
- JSONB columns for complex nested data

If migration file name differs from expected, rename or note the actual filename.
  </action>
  <verify>
Run `npx drizzle-kit push` and confirm "Applied" message.
Check Supabase dashboard or run: `npx drizzle-kit studio` to view table.
  </verify>
  <done>
Migration file exists and has been applied. Analyses table visible in database with correct structure.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no type errors
2. `src/lib/analysis/schemas.ts` exports all required types
3. `src/lib/db/schema.ts` includes analyses table
4. Migration file exists in drizzle/ directory
5. Database has analyses table with correct columns
</verification>

<success_criteria>
- Analysis schemas validate sample data correctly
- TypeScript types can be imported and used
- Database table exists and can store analysis records
- Foreign keys properly reference profiles, companies, icp_profiles
</success_criteria>

<output>
After completion, create `.planning/phases/04-ai-analysis/04-01-SUMMARY.md`
</output>
