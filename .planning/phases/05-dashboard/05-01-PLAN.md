---
phase: 05-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/db/schema.ts
  - supabase/migrations/0005_add_is_archived.sql
  - src/lib/dashboard/queries.ts
  - src/lib/dashboard/utils.ts
autonomous: true

must_haves:
  truths:
    - "Dashboard can query analyses filtered by score range, ICP match, industry, date, and archived status"
    - "CSV export produces valid downloadable file with correct columns"
    - "Clipboard copy produces CRM-friendly plain text format"
  artifacts:
    - path: "supabase/migrations/0005_add_is_archived.sql"
      provides: "isArchived column on analyses table"
      contains: "ALTER TABLE analyses ADD COLUMN is_archived"
    - path: "src/lib/dashboard/queries.ts"
      provides: "Filtered dashboard queries using Drizzle"
      exports: ["getDashboardLeads", "getDashboardLeadCount", "getIndustryOptions"]
    - path: "src/lib/dashboard/utils.ts"
      provides: "CSV generation and clipboard formatting helpers"
      exports: ["leadsToCSV", "leadToClipboardText", "downloadCSV"]
  key_links:
    - from: "src/lib/dashboard/queries.ts"
      to: "src/lib/db/schema.ts"
      via: "Drizzle ORM joins"
      pattern: "analyses.*companies"
---

<objective>
Create the data foundation for the dashboard: add isArchived column to analyses, build filtered Drizzle query builders that join analyses with companies, and create CSV/clipboard utility functions.

Purpose: All dashboard UI plans depend on these queries and utilities. Separating data logic from UI keeps plans focused and enables clean imports.
Output: Migration file, queries.ts with filtered dashboard queries, utils.ts with export/clipboard helpers.
</objective>

<execution_context>
@C:\Users\farre\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\farre\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/db/schema.ts
@src/lib/db/index.ts
@src/lib/analysis/schemas.ts
@src/lib/analysis/actions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add isArchived column and build dashboard queries</name>
  <files>
    src/lib/db/schema.ts
    supabase/migrations/0005_add_is_archived.sql
    src/lib/dashboard/queries.ts
  </files>
  <action>
    1. Update `src/lib/db/schema.ts` - Add `isArchived` boolean column to the `analyses` table:
       - `isArchived: boolean('is_archived').default(false).notNull()`
       - Place it after the `objections` field, before timestamps

    2. Create `supabase/migrations/0005_add_is_archived.sql`:
       ```sql
       ALTER TABLE analyses ADD COLUMN is_archived boolean NOT NULL DEFAULT false;
       ```

    3. Create `src/lib/dashboard/queries.ts` with these functions:

    **`getDashboardLeads(filters)`** - Main query function:
    - Accept filters object: `{ scoreMin?: number, scoreMax?: number, icpMatchMin?: number, icpMatchMax?: number, industry?: string, dateFrom?: string, dateTo?: string, showArchived?: boolean, sortBy?: 'score' | 'icpMatch' | 'date' | 'name', sortDir?: 'asc' | 'desc' }`
    - Uses `'use server'` directive at top of file
    - Get authenticated user via createClient/getUser (same pattern as analysis/actions.ts)
    - Query: `db.select({ analysis: analyses, company: companies }).from(analyses).innerJoin(companies, eq(analyses.companyId, companies.id))`
    - Always filter by `analyses.userId = user.id`
    - Default: filter `analyses.isArchived = false` unless `showArchived` is true
    - Build dynamic WHERE conditions array using Drizzle `and()`:
      - scoreMin/scoreMax: `gte(analyses.leadScore, scoreMin)`, `lte(analyses.leadScore, scoreMax)`
      - icpMatchMin/icpMatchMax: `gte(analyses.icpMatchPercentage, min)`, `lte(analyses.icpMatchPercentage, max)`
      - industry: `eq(companies.industry, industry)` (exact match)
      - dateFrom/dateTo: `gte(analyses.createdAt, new Date(dateFrom))`, `lte(analyses.createdAt, new Date(dateTo))`
    - Sort: map sortBy to column (score -> analyses.leadScore, icpMatch -> analyses.icpMatchPercentage, date -> analyses.createdAt, name -> companies.name), apply desc() or asc() based on sortDir. Default: `desc(analyses.leadScore)` then `desc(analyses.createdAt)` as tiebreaker
    - Return type: `Array<{ analysis: Analysis; company: Company }>`

    **`getDashboardLeadCount(filters)`** - Count query for filter feedback:
    - Same filter logic but returns `count(*)` instead of full rows
    - Used for showing "N results" in filter bar

    **`getIndustryOptions()`** - Distinct industries for filter dropdown:
    - Query: `db.selectDistinct({ industry: companies.industry }).from(companies).innerJoin(analyses, eq(...)).where(eq(analyses.userId, user.id))`
    - Return sorted array of non-null industry strings

    **`archiveLead(analysisId: string)`** - Archive server action:
    - Verify ownership, then `db.update(analyses).set({ isArchived: true }).where(and(eq(analyses.id, analysisId), eq(analyses.userId, user.id)))`
    - Return `{ success: true }` or `{ success: false, error: string }`

    **`unarchiveLead(analysisId: string)`** - Unarchive server action:
    - Same pattern but sets `isArchived: false`

    Import from drizzle-orm: `eq`, `and`, `gte`, `lte`, `desc`, `asc`, `count`, `sql`.
    Import createClient from `@/lib/supabase/server`, db from `@/lib/db`, schema tables from `@/lib/db/schema`.
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify types compile.
    Run the migration: `psql` or via Supabase dashboard to apply 0005.
  </verify>
  <done>
    schema.ts has isArchived on analyses table. queries.ts exports getDashboardLeads, getDashboardLeadCount, getIndustryOptions, archiveLead, unarchiveLead. Migration file exists. TypeScript compiles clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create dashboard utility functions</name>
  <files>
    src/lib/dashboard/utils.ts
  </files>
  <action>
    Create `src/lib/dashboard/utils.ts` with these client-side utility functions (NO 'use server' - these run in the browser):

    **`leadsToCSV(leads: DashboardLead[])`** - Generate CSV string:
    - Type `DashboardLead` = `{ analysis: Analysis; company: Company }` (import types from schema)
    - Columns: Company Name, Domain, Industry, Employee Count, Lead Score, Score Label, ICP Match %, Location, Analyzed Date
    - Header row first
    - For each lead: escape values (wrap in quotes if contains comma/quote/newline, double-escape internal quotes)
    - Date format: YYYY-MM-DD
    - Score label: use getScoreLabel from analysis/schemas
    - Return CSV as string

    **`downloadCSV(csvContent: string, filename: string)`** - Trigger browser download:
    - Create Blob with type 'text/csv;charset=utf-8;'
    - Create object URL, create temp anchor element, click it, revoke URL
    - Filename should include date, e.g., `leadqual-export-2026-02-10.csv`

    **`leadToClipboardText(lead: DashboardLead)`** - CRM-friendly plain text:
    - Format as structured plain text (NOT markdown - for universal CRM compatibility):
      ```
      === LEAD ANALYSIS: {Company Name} ===

      LEAD SCORE: {score}/100 ({label})
      ICP MATCH: {icpMatch}%

      COMPANY INFO
      Domain: {domain}
      Industry: {industry}
      Size: {employeeCount}
      Location: {location}

      INSIGHTS
      {insights.summary}
      Strengths: {bullet list}
      Concerns: {bullet list}

      PITCH ANGLES
      1. {headline}: {explanation}
      2. ...

      OBJECTIONS
      1. {objection} ({likelihood})
         Response: {recommendedResponse}
      2. ...

      Analyzed: {date}
      Generated by LeadQual
      ```
    - Return string

    **`copyToClipboard(text: string)`** - Copy with feedback:
    - Use `navigator.clipboard.writeText(text)` in try/catch
    - Return `{ success: true }` or `{ success: false, error: string }`
    - Fallback: if clipboard API unavailable, return error with message
  </action>
  <verify>
    Run `npx tsc --noEmit` to confirm types compile. Manually inspect that CSV escaping handles edge cases (commas in company names, quotes in descriptions).
  </verify>
  <done>
    utils.ts exports leadsToCSV, downloadCSV, leadToClipboardText, copyToClipboard. All functions are typed with DashboardLead type. TypeScript compiles clean.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- Migration file 0005 exists with correct ALTER TABLE
- schema.ts analyses table includes isArchived boolean
- queries.ts handles all filter combinations (score, ICP, industry, date, archived)
- utils.ts CSV output has proper escaping
- utils.ts clipboard format is plain text, not markdown
</verification>

<success_criteria>
- Database schema extended with isArchived column
- All dashboard queries are built and typed
- CSV and clipboard utilities ready for UI consumption
- Zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-dashboard/05-01-SUMMARY.md`
</output>
